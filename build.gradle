import java.util.regex.Matcher
import java.util.regex.Pattern

// Top-level build file where you can add configuration options common to all sub-projects/modules.

def is_windows = System.getProperty("os.name").toLowerCase().startsWith("windows")

buildscript {
    ext.kotlin_version = '1.3.50'
    repositories {
        google()
        jcenter()

    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.3'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
    parse_local_properties()
    get_current_build_type(project)
    ext {
        isWindows = is_windows
        startCommands = { commands ->
            return start_commands(commands)
        }
        compileAidl = { interfaceFiles = [], importIncludes = [], sources = [] ->
            compile_aidl(project, interfaceFiles, importIncludes, sources)
        }
        wslPath = { path ->
            return wsl_path(path)
        }
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

def parse_local_properties(){
    File file = rootProject.file('local.properties')
    if(file.exists()) {
        InputStream inputStream = rootProject.file('local.properties').newDataInputStream();
        Properties properties = new Properties()
        properties.load(inputStream)

        if (properties.containsKey("chromium_dir")) {
            ext.chromium_dir = properties.getProperty("chromium_dir")
        }
        if (properties.containsKey("out_dir")) {
            ext.out_dir = properties.getProperty("out_dir")
        }
    }
}

def get_current_build_type(project) {
    if (!hasProperty("buildType")) {
        ext.buildType = new HashMap<String, String>()
    }
    def taskRequests = gradle.startParameter.taskRequests
    taskRequests.each { request ->
        request.args.each { args ->
            if (args.startsWith(":${project.name}")) {
                def pattern
                if (args.contains("assemble")) {
                    pattern = Pattern.compile("assemble(\\w*)(Release|Debug)")
                } else {
                    pattern = Pattern.compile("generate(\\w*)(Release|Debug)")
                }
                def matcher = pattern.matcher(args)
                if (matcher.find()) {
                    ext.buildType[project.name] = matcher.group(matcher.groupCount()).toLowerCase()
                }
            }
        }
    }
}

def start_commands(commands) {
    def isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows")
    if (isWindows) {
        commands << "cmd"
        commands << "/c"
    } else {
        commands << "bash"
        commands << "-c"
    }
}

def compile_aidl(project, interfaceFiles = [], importIncludes = [], sources = []) {
    sources.each { source ->
        def commands = []
        startCommands(commands)
        commands << "${project.android.sdkDirectory.path}/build-tools/${project.android.buildToolsVersion}/aidl${isWindows ? ".exe" : ""}"
        commands << "-p${project.android.sdkDirectory.path}/platforms/${project.android.compileSdkVersion}/framework.aidl"
        interfaceFiles.each { interfaceFile ->
            commands << "-p$interfaceFile"
        }
        def outDir = new File("${project.projectDir.path}/src/main/generated")
        if (!outDir.exists()) {
            outDir.mkdirs()
        }
        commands << "-o${outDir.path}"
        importIncludes.each { include ->
            commands << "-I$include"
        }
        commands << source
        exec {
            commandLine = commands
        }
    }
}

def wsl_path(path) {
    if (!isWindows) {
        return path
    }
    def splits = path.split(":")
    if (splits.length == 2) {
        def diskLabel = splits[0].toLowerCase()
        if (diskLabel.length() > 1) {
            return path
        }
        def relativePath = splits[1].replaceAll('\\\\', '/')
        return "/mnt/$diskLabel${relativePath}"
    }
    return path
}